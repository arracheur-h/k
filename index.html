<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karambit Rivals - Ultra Realistic FPS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Arial', sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        /* Menu principal */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }
        
        #main-menu.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .menu-container {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00d4ff;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.5);
        }
        
        .menu-title {
            text-align: center;
            color: #00d4ff;
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
            letter-spacing: 3px;
        }
        
        .menu-subtitle {
            text-align: center;
            color: #ffd700;
            font-size: 20px;
            margin-bottom: 40px;
            font-style: italic;
        }
        
        .settings-section {
            margin: 30px 0;
        }
        
        .settings-title {
            color: #00d4ff;
            font-size: 24px;
            margin-bottom: 20px;
            border-bottom: 2px solid #00d4ff;
            padding-bottom: 10px;
        }
        
        .setting-item {
            margin: 20px 0;
        }
        
        .setting-label {
            color: white;
            font-size: 16px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .setting-value {
            color: #00d4ff;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }
        
        .play-button {
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #00d4ff, #0066ff);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .play-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 212, 255, 0.6);
            background: linear-gradient(135deg, #00e4ff, #0077ff);
        }
        
        .play-button:active {
            transform: translateY(0);
        }
        
        /* Panneau d'info en jeu */
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 320px;
            z-index: 1000;
            display: none;
        }
        
        .info-panel.visible {
            display: block;
        }
        
        .info-panel h2 {
            margin: 0 0 15px 0;
            font-size: 24px;
            color: #00d4ff;
        }
        
        .info-panel h3 {
            margin: 15px 0 10px 0;
            color: #00d4ff;
            font-size: 18px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .icon {
            margin-right: 10px;
            font-size: 18px;
        }
        
        /* Menu pause (ESC) */
        #pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        #pause-menu.visible {
            display: flex;
        }
        
        .pause-container {
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }
        
        .pause-title {
            color: #00d4ff;
            font-size: 36px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .menu-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 212, 255, 0.2);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .menu-button:hover {
            background: rgba(0, 212, 255, 0.4);
            transform: translateX(5px);
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Menu principal -->
    <div id="main-menu">
        <div class="menu-container">
            <h1 class="menu-title">‚öîÔ∏è KARAMBIT RIVALS ‚öîÔ∏è</h1>
            <p class="menu-subtitle">Ultra-Realistic FPS Experience</p>
            
            <div class="settings-section">
                <h2 class="settings-title">‚öôÔ∏è Param√®tres</h2>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>üìê Champ de vision (FOV)</span>
                        <span class="setting-value" id="fov-value">75¬∞</span>
                    </div>
                    <input type="range" id="fov-slider" min="60" max="110" value="75" step="5">
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>üñ±Ô∏è Sensibilit√© souris</span>
                        <span class="setting-value" id="sensitivity-value">1.0x</span>
                    </div>
                    <input type="range" id="sensitivity-slider" min="0.3" max="2.0" value="1.0" step="0.1">
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>üé® Qualit√© des ombres</span>
                        <span class="setting-value" id="shadows-value">Activ√©es</span>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="shadows-checkbox" checked>
                        <label for="shadows-checkbox" style="color: white;">Ombres dynamiques</label>
                    </div>
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>‚ÑπÔ∏è Afficher les contr√¥les</span>
                        <span class="setting-value" id="controls-value">Activ√©</span>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="controls-checkbox" checked>
                        <label for="controls-checkbox" style="color: white;">Panneau d'aide</label>
                    </div>
                </div>
            </div>
            
            <button class="play-button" id="play-button">üéÆ JOUER üéÆ</button>
        </div>
    </div>
    
    <!-- Menu pause (ESC) -->
    <div id="pause-menu">
        <div class="pause-container">
            <h2 class="pause-title">‚è∏Ô∏è PAUSE</h2>
            
            <div class="settings-section">
                <div class="setting-item">
                    <div class="setting-label">
                        <span>üìê FOV</span>
                        <span class="setting-value" id="fov-value-pause">75¬∞</span>
                    </div>
                    <input type="range" id="fov-slider-pause" min="60" max="110" value="75" step="5">
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <span>üñ±Ô∏è Sensibilit√©</span>
                        <span class="setting-value" id="sensitivity-value-pause">1.0x</span>
                    </div>
                    <input type="range" id="sensitivity-slider-pause" min="0.3" max="2.0" value="1.0" step="0.1">
                </div>
            </div>
            
            <button class="menu-button" id="resume-button">‚ñ∂Ô∏è Reprendre</button>
            <button class="menu-button" id="restart-button">üîÑ Recommencer</button>
        </div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div class="info-panel" id="info-panel">
        <h2>‚öîÔ∏è Karambit Rivals</h2>
        <div class="control-item">
            <span class="icon">üñ±Ô∏è</span>
            <span>Souris pour regarder autour</span>
        </div>
        <div class="control-item">
            <span class="icon">‚å®Ô∏è</span>
            <span>ZQSD / WASD pour bouger</span>
        </div>
        <div class="control-item">
            <span class="icon">‚è∏Ô∏è</span>
            <span>ESC pour pause/param√®tres</span>
        </div>
        <h3>üé¨ Animations Premium:</h3>
        <div class="control-item">
            <span class="icon">üîç</span>
            <span><strong>F</strong> - Inspect (5 phases)</span>
        </div>
        <div class="control-item">
            <span class="icon">üåÄ</span>
            <span><strong>R</strong> - Spin ultra-rapide</span>
        </div>
        <div class="control-item">
            <span class="icon">üéØ</span>
            <span><strong>E</strong> - Flip pr√©cis</span>
        </div>
        <div class="control-item">
            <span class="icon">‚ú®</span>
            <span><strong>G</strong> - Twirl en spirale</span>
        </div>
        <div class="control-item">
            <span class="icon">üé™</span>
            <span><strong>T</strong> - Jonglage 2 mains</span>
        </div>
        <div class="control-item" style="background: rgba(255, 215, 0, 0.1); padding: 8px; border-radius: 5px; margin-top: 10px;">
            <span class="icon">üé•</span>
            <span><strong>C</strong> - CIN√âMATIQUE (6s)</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === GESTION DU MENU ET PARAM√àTRES ===
        let gameStarted = false;
        let isPaused = false;
        let settings = {
            fov: 75,
            sensitivity: 1.0,
            shadows: true,
            showControls: true
        };
        
        // √âl√©ments du menu
        const mainMenu = document.getElementById('main-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const infoPanel = document.getElementById('info-panel');
        const playButton = document.getElementById('play-button');
        const resumeButton = document.getElementById('resume-button');
        const restartButton = document.getElementById('restart-button');
        
        // Sliders menu principal
        const fovSlider = document.getElementById('fov-slider');
        const fovValue = document.getElementById('fov-value');
        const sensitivitySlider = document.getElementById('sensitivity-slider');
        const sensitivityValue = document.getElementById('sensitivity-value');
        const shadowsCheckbox = document.getElementById('shadows-checkbox');
        const shadowsValue = document.getElementById('shadows-value');
        const controlsCheckbox = document.getElementById('controls-checkbox');
        const controlsValue = document.getElementById('controls-value');
        
        // Sliders menu pause
        const fovSliderPause = document.getElementById('fov-slider-pause');
        const fovValuePause = document.getElementById('fov-value-pause');
        const sensitivitySliderPause = document.getElementById('sensitivity-slider-pause');
        const sensitivityValuePause = document.getElementById('sensitivity-value-pause');
        
        // Event listeners pour les sliders du menu principal
        fovSlider.addEventListener('input', (e) => {
            settings.fov = parseInt(e.target.value);
            fovValue.textContent = settings.fov + '¬∞';
            fovSliderPause.value = settings.fov;
            fovValuePause.textContent = settings.fov + '¬∞';
        });
        
        sensitivitySlider.addEventListener('input', (e) => {
            settings.sensitivity = parseFloat(e.target.value);
            sensitivityValue.textContent = settings.sensitivity.toFixed(1) + 'x';
            sensitivitySliderPause.value = settings.sensitivity;
            sensitivityValuePause.textContent = settings.sensitivity.toFixed(1) + 'x';
        });
        
        shadowsCheckbox.addEventListener('change', (e) => {
            settings.shadows = e.target.checked;
            shadowsValue.textContent = settings.shadows ? 'Activ√©es' : 'D√©sactiv√©es';
        });
        
        controlsCheckbox.addEventListener('change', (e) => {
            settings.showControls = e.target.checked;
            controlsValue.textContent = settings.showControls ? 'Activ√©' : 'D√©sactiv√©';
        });
        
        // Event listeners pour les sliders du menu pause
        fovSliderPause.addEventListener('input', (e) => {
            settings.fov = parseInt(e.target.value);
            fovValuePause.textContent = settings.fov + '¬∞';
            fovSlider.value = settings.fov;
            fovValue.textContent = settings.fov + '¬∞';
            if (camera) {
                targetFOV = settings.fov;
            }
        });
        
        sensitivitySliderPause.addEventListener('input', (e) => {
            settings.sensitivity = parseFloat(e.target.value);
            sensitivityValuePause.textContent = settings.sensitivity.toFixed(1) + 'x';
            sensitivitySlider.value = settings.sensitivity;
            sensitivityValue.textContent = settings.sensitivity.toFixed(1) + 'x';
        });
        
        // Bouton jouer
        playButton.addEventListener('click', () => {
            gameStarted = true;
            mainMenu.classList.add('hidden');
            if (settings.showControls) {
                infoPanel.classList.add('visible');
            }
            // Verrouiller le pointeur pour un vrai FPS
            document.getElementById('canvas-container').requestPointerLock();
        });
        
        // Bouton reprendre
        resumeButton.addEventListener('click', () => {
            isPaused = false;
            pauseMenu.classList.remove('visible');
            document.getElementById('canvas-container').requestPointerLock();
        });
        
        // Bouton recommencer
        restartButton.addEventListener('click', () => {
            location.reload();
        });
        
        // Gestion de la touche ESC pour le menu pause
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && gameStarted) {
                isPaused = !isPaused;
                if (isPaused) {
                    pauseMenu.classList.add('visible');
                    document.exitPointerLock();
                } else {
                    pauseMenu.classList.remove('visible');
                    document.getElementById('canvas-container').requestPointerLock();
                }
            }
        });
        
        // Configuration de la sc√®ne
        const scene = new THREE.Scene();
        
        // === SKYBOX MAGNIFIQUE ===
        // Gradient de ciel r√©aliste
        const vertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        const fragmentShader = `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `;
        
        const skyGeo = new THREE.SphereGeometry(500, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                topColor: { value: new THREE.Color(0x0077ff) }, // Bleu ciel
                bottomColor: { value: new THREE.Color(0xff6b35) }, // Orange sunset
                offset: { value: 33 },
                exponent: { value: 0.6 }
            },
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);
        
        // Fog pour plus de profondeur
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 100);
        
        // Cam√©ra premi√®re personne
        const camera = new THREE.PerspectiveCamera(
            settings.fov,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 0);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lumi√®res am√©lior√©es pour un rendu r√©aliste
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        // Lumi√®re principale (soleil)
        const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.2);
        sunLight.position.set(10, 15, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 50;
        scene.add(sunLight);
        
        // Lumi√®re d'appoint pour le couteau
        const knifeLight = new THREE.PointLight(0x00d4ff, 0.5, 3);
        knifeLight.position.set(0.5, 0, -0.3);
        scene.add(knifeLight);
        
        // Rim light pour effet cin√©matique
        const rimLight = new THREE.DirectionalLight(0x4466ff, 0.8);
        rimLight.position.set(-5, 3, -5);
        scene.add(rimLight);
        
        // Base plate am√©lior√©e
        const platformGeometry = new THREE.BoxGeometry(12, 0.5, 12);
        const platformMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a3e,
            roughness: 0.4,
            metalness: 0.6,
            emissive: 0x0a0a1e,
            emissiveIntensity: 0.2
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.y = -2.5;
        platform.receiveShadow = true;
        scene.add(platform);
        
        // Bordures de la plateforme (effet n√©on)
        const borderMaterial = new THREE.MeshBasicMaterial({
            color: 0x00d4ff,
            transparent: true,
            opacity: 0.6
        });
        
        // Bordures des 4 c√¥t√©s
        const border1 = new THREE.Mesh(new THREE.BoxGeometry(12.2, 0.1, 0.1), borderMaterial);
        border1.position.set(0, -2.25, 6);
        scene.add(border1);
        
        const border2 = new THREE.Mesh(new THREE.BoxGeometry(12.2, 0.1, 0.1), borderMaterial);
        border2.position.set(0, -2.25, -6);
        scene.add(border2);
        
        const border3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 12), borderMaterial);
        border3.position.set(6, -2.25, 0);
        scene.add(border3);
        
        const border4 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 12), borderMaterial);
        border4.position.set(-6, -2.25, 0);
        scene.add(border4);
        
        // Grille styl√©e
        const gridHelper = new THREE.GridHelper(12, 20, 0x00d4ff, 0x1a1a2e);
        gridHelper.position.y = -2.24;
        gridHelper.material.transparent = true;
        gridHelper.material.opacity = 0.5;
        scene.add(gridHelper);
        
        // === PARTICULES ATMOSPH√âRIQUES ===
        let particleCount = 100;
        let particleVelocities = [];
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 50;
            particlePositions[i * 3 + 1] = Math.random() * 30 - 10;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 50;
            
            particleVelocities.push({
                x: (Math.random() - 0.5) * 0.02,
                y: Math.random() * 0.02 + 0.01,
                z: (Math.random() - 0.5) * 0.02
            });
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0x00d4ff,
            size: 0.1,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleSystem);
        
        // Groupe viewmodel attach√© √† la cam√©ra
        const viewmodelGroup = new THREE.Group();
        camera.add(viewmodelGroup);
        scene.add(camera);
        
        // Mat√©riau pour les bras R6
        const armMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffcc99,
            roughness: 0.5,
            metalness: 0.2
        });
        
        // BRAS DROIT
        const rightArmGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15);
        const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
        rightArm.position.set(0.25, -0.3, -0.5);
        rightArm.castShadow = true;
        viewmodelGroup.add(rightArm);
        
        // BRAS GAUCHE
        const leftArmGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15);
        const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
        leftArm.position.set(-0.25, -0.3, -0.5);
        leftArm.castShadow = true;
        viewmodelGroup.add(leftArm);
        
        // === KARAMBIT ULTRA-R√âALISTE (Style Rivals) ===
        const knifeGroup = new THREE.Group();
        
        // Mat√©riaux de haute qualit√© (d√©clar√©s globalement pour animations)
        let bladeMaterial, bladeEdgeMaterial, handleMaterial, handleGripMaterial, goldAccentMaterial, glowMaterial, sparkleMaterial;
        
        bladeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf0f0f0,
            metalness: 0.98,
            roughness: 0.12,
            emissive: 0x111111,
            emissiveIntensity: 0.15,
            envMapIntensity: 1.5
        });
        
        bladeEdgeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            metalness: 1.0,
            roughness: 0.05,
            emissive: 0x333333,
            emissiveIntensity: 0.25
        });
        
        handleMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0a0a0a,
            roughness: 0.5,
            metalness: 0.3
        });
        
        handleGripMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a,
            roughness: 0.8,
            metalness: 0.1
        });
        
        goldAccentMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffd700,
            metalness: 0.95,
            roughness: 0.15,
            emissive: 0x664400,
            emissiveIntensity: 0.4
        });
        
        // === LAME PRINCIPALE (Forme courb√©e r√©aliste) ===
        // Cr√©er la courbure de la lame par segments
        const bladeSegments = [];
        const numSegments = 8;
        
        for (let i = 0; i < numSegments; i++) {
            const progress = i / numSegments;
            const curve = Math.sin(progress * Math.PI * 0.6) * 0.15;
            
            const segmentGeo = new THREE.BoxGeometry(0.025, 0.055, 0.08);
            const segment = new THREE.Mesh(segmentGeo, bladeMaterial);
            
            segment.position.y = -0.05 - (progress * 0.32);
            segment.position.x = curve;
            segment.rotation.z = progress * 0.5 + 0.2;
            
            knifeGroup.add(segment);
            bladeSegments.push(segment);
        }
        
        // Pointe ac√©r√©e (bout du karambit)
        const tipGeo = new THREE.ConeGeometry(0.04, 0.12, 4);
        const tip = new THREE.Mesh(tipGeo, bladeEdgeMaterial);
        tip.position.set(0.15, -0.35, 0);
        tip.rotation.z = -0.7;
        knifeGroup.add(tip);
        
        // Tranchant brillant sur toute la longueur
        const edgeCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0.02, 0, 0.04),
            new THREE.Vector3(0.05, -0.1, 0.04),
            new THREE.Vector3(0.08, -0.2, 0.04),
            new THREE.Vector3(0.12, -0.3, 0.04),
            new THREE.Vector3(0.14, -0.35, 0.04)
        ]);
        
        const edgeGeo = new THREE.TubeGeometry(edgeCurve, 20, 0.008, 3, false);
        const edge = new THREE.Mesh(edgeGeo, bladeEdgeMaterial);
        knifeGroup.add(edge);
        
        // D√©tails sur la lame (lignes de style)
        for (let i = 0; i < 3; i++) {
            const lineGeo = new THREE.BoxGeometry(0.015, 0.25, 0.002);
            const line = new THREE.Mesh(lineGeo, new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.9,
                roughness: 0.3
            }));
            line.position.set(-0.02 - i * 0.01, -0.15, 0.02);
            line.rotation.z = 0.3;
            knifeGroup.add(line);
        }
        
        // === GARDE (Transition lame-manche) ===
        const guardGeo = new THREE.BoxGeometry(0.08, 0.04, 0.1);
        const guard = new THREE.Mesh(guardGeo, goldAccentMaterial);
        guard.position.set(0, 0.02, 0);
        knifeGroup.add(guard);
        
        // === MANCHE (Grip d√©taill√©) ===
        // Base du manche
        const handleBaseGeo = new THREE.BoxGeometry(0.055, 0.22, 0.09);
        const handleBase = new THREE.Mesh(handleBaseGeo, handleMaterial);
        handleBase.position.set(0, 0.12, 0);
        knifeGroup.add(handleBase);
        
        // Texture grip (lignes crois√©es)
        for (let i = 0; i < 6; i++) {
            const gripLineGeo = new THREE.BoxGeometry(0.057, 0.012, 0.091);
            const gripLine = new THREE.Mesh(gripLineGeo, handleGripMaterial);
            gripLine.position.set(0, 0.04 + i * 0.03, 0);
            knifeGroup.add(gripLine);
        }
        
        // Rivets dor√©s (3 de chaque c√¥t√©)
        for (let i = 0; i < 3; i++) {
            const rivetGeo = new THREE.SphereGeometry(0.01, 8, 8);
            
            const rivet1 = new THREE.Mesh(rivetGeo, goldAccentMaterial);
            rivet1.position.set(0.015, 0.06 + i * 0.06, 0.047);
            knifeGroup.add(rivet1);
            
            const rivet2 = new THREE.Mesh(rivetGeo, goldAccentMaterial);
            rivet2.position.set(0.015, 0.06 + i * 0.06, -0.047);
            knifeGroup.add(rivet2);
        }
        
        // Bande dor√©e centrale
        const centerBandGeo = new THREE.BoxGeometry(0.058, 0.03, 0.092);
        const centerBand = new THREE.Mesh(centerBandGeo, goldAccentMaterial);
        centerBand.position.set(0, 0.12, 0);
        knifeGroup.add(centerBand);
        
        // === POMEAU (Fin du manche) ===
        const pommelGeo = new THREE.CylinderGeometry(0.05, 0.04, 0.025, 8);
        const pommel = new THREE.Mesh(pommelGeo, goldAccentMaterial);
        pommel.position.set(0, 0.235, 0);
        pommel.rotation.x = Math.PI / 2;
        knifeGroup.add(pommel);
        
        // === ANNEAU SIGNATURE DU KARAMBIT ===
        const ringGeo = new THREE.TorusGeometry(0.055, 0.015, 12, 24);
        const ring = new THREE.Mesh(ringGeo, goldAccentMaterial);
        ring.position.set(0, 0.27, 0);
        ring.rotation.x = Math.PI / 2;
        knifeGroup.add(ring);
        
        // D√©tails sur l'anneau (gravures)
        const ringDetailGeo = new THREE.TorusGeometry(0.056, 0.004, 8, 24);
        const ringDetail = new THREE.Mesh(ringDetailGeo, new THREE.MeshStandardMaterial({
            color: 0xffaa00,
            metalness: 1.0,
            roughness: 0.2,
            emissive: 0xff8800,
            emissiveIntensity: 0.3
        }));
        ringDetail.position.set(0, 0.27, 0);
        ringDetail.rotation.x = Math.PI / 2;
        knifeGroup.add(ringDetail);
        
        // === EFFETS VISUELS (Style Rivals) ===
        // Glow effect autour de la lame
        const glowGeo = new THREE.BoxGeometry(0.04, 0.35, 0.1);
        glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00d4ff,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
        });
        const glow = new THREE.Mesh(glowGeo, glowMaterial);
        glow.position.set(0.04, -0.15, 0);
        glow.rotation.z = 0.3;
        knifeGroup.add(glow);
        
        // Particules d'√©clat sur la lame
        const sparkleGeo = new THREE.SphereGeometry(0.008, 4, 4);
        sparkleMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });
        
        for (let i = 0; i < 5; i++) {
            const sparkle = new THREE.Mesh(sparkleGeo, sparkleMaterial);
            sparkle.position.set(
                Math.random() * 0.08 - 0.02,
                -0.05 - Math.random() * 0.3,
                0.04
            );
            knifeGroup.add(sparkle);
        }
        
        // Position du couteau
        knifeGroup.position.set(0.35, -0.28, -0.45);
        knifeGroup.rotation.set(-0.1, 0.4, 0.3);
        viewmodelGroup.add(knifeGroup);
        
        // === CONTR√îLES ===
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        
        // Gestion du mouvement de la souris avec pointer lock
        document.addEventListener('mousemove', (e) => {
            if (!isPaused && document.pointerLockElement) {
                // Utiliser movementX/Y pour un vrai FPS
                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;
                
                targetRotationY -= movementX * 0.002 * settings.sensitivity;
                targetRotationX -= movementY * 0.002 * settings.sensitivity;
                
                // Limiter la rotation verticale
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
            }
        });
        
        const keys = {};
        const moveSpeed = 0.1;
        
        let currentAnimation = 'idle';
        let animationProgress = 0;
        let animationDuration = 0;
        let cameraFOV = settings.fov;
        let targetFOV = settings.fov;
        
        document.addEventListener('keydown', (e) => {
            if (isPaused) return; // Ignorer les touches si en pause
            
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'f' && currentAnimation === 'idle') {
                currentAnimation = 'inspect';
                animationProgress = 0;
                animationDuration = 5.0;
            }
            if (e.key.toLowerCase() === 'r' && currentAnimation === 'idle') {
                currentAnimation = 'spin';
                animationProgress = 0;
                animationDuration = 2.2;
            }
            if (e.key.toLowerCase() === 'e' && currentAnimation === 'idle') {
                currentAnimation = 'flip';
                animationProgress = 0;
                animationDuration = 2.0;
            }
            if (e.key.toLowerCase() === 'g' && currentAnimation === 'idle') {
                currentAnimation = 'twirl';
                animationProgress = 0;
                animationDuration = 3.2;
            }
            if (e.key.toLowerCase() === 't' && currentAnimation === 'idle') {
                currentAnimation = 'juggle';
                animationProgress = 0;
                animationDuration = 4.0;
            }
            if (e.key.toLowerCase() === 'c' && currentAnimation === 'idle') {
                currentAnimation = 'cinematic';
                animationProgress = 0;
                animationDuration = 6.0;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        function updateMovement() {
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();
            
            if (keys['z'] || keys['w']) {
                camera.position.add(forward.multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                camera.position.sub(forward.multiplyScalar(moveSpeed));
            }
            if (keys['q'] || keys['a']) {
                camera.position.sub(right.multiplyScalar(moveSpeed));
            }
            if (keys['d']) {
                camera.position.add(right.multiplyScalar(moveSpeed));
            }
        }
        
        // Easing functions
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }
        
        function easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
        }
        
        function smoothLerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function resetKnifePosition() {
            knifeGroup.position.set(0.35, -0.28, -0.45);
            knifeGroup.rotation.set(-0.1, 0.4, 0.3);
        }
        
        function updateKnifeAnimation(deltaTime, time) {
            if (currentAnimation === 'idle') {
                resetKnifePosition();
                knifeGroup.rotation.y = 0.4 + Math.sin(time * 0.7) * 0.02;
                knifeGroup.rotation.z = 0.3 + Math.sin(time * 0.9) * 0.015;
                targetFOV = settings.fov; // Utiliser le FOV des param√®tres
                return;
            }
            
            animationProgress += deltaTime;
            const progress = Math.min(animationProgress / animationDuration, 1);
            
            if (currentAnimation === 'inspect') {
                if (progress < 0.25) {
                    const phase = easeInOutCubic(progress / 0.25);
                    knifeGroup.position.x = smoothLerp(0.35, 0, phase);
                    knifeGroup.position.y = smoothLerp(-0.28, -0.05, phase);
                    knifeGroup.position.z = smoothLerp(-0.45, -0.3, phase);
                    knifeGroup.rotation.x = smoothLerp(-0.1, 0.5, phase);
                    knifeGroup.rotation.y = smoothLerp(0.4, 0, phase);
                    rightArm.position.x = smoothLerp(0.25, 0.15, phase);
                    leftArm.position.x = smoothLerp(-0.25, -0.15, phase);
                    targetFOV = smoothLerp(75, 70, phase);
                } else if (progress < 0.75) {
                    const phase = (progress - 0.25) / 0.5;
                    const rotations = phase * Math.PI * 3;
                    knifeGroup.position.set(0, -0.05, -0.3);
                    knifeGroup.rotation.x = 0.5 + Math.sin(rotations) * 0.3;
                    knifeGroup.rotation.y = rotations;
                    knifeGroup.rotation.z = Math.cos(rotations * 0.5) * 0.2;
                    targetFOV = 70;
                } else {
                    const phase = easeOutBack((progress - 0.75) / 0.25);
                    knifeGroup.position.x = smoothLerp(0, 0.35, phase);
                    knifeGroup.position.y = smoothLerp(-0.05, -0.28, phase);
                    knifeGroup.position.z = smoothLerp(-0.3, -0.45, phase);
                    knifeGroup.rotation.x = smoothLerp(0.5, -0.1, phase);
                    knifeGroup.rotation.y = smoothLerp(Math.PI * 1.5, 0.4, phase);
                    rightArm.position.x = smoothLerp(0.15, 0.25, phase);
                    leftArm.position.x = smoothLerp(-0.15, -0.25, phase);
                    targetFOV = smoothLerp(70, 75, phase);
                }
            }
            
            else if (currentAnimation === 'spin') {
                const spinRotations = easeOutElastic(progress) * Math.PI * 12;
                const shake = Math.sin(progress * Math.PI) * 0.06;
                knifeGroup.position.x = 0.35 + Math.cos(spinRotations * 4) * shake;
                knifeGroup.position.y = -0.28 + Math.sin(progress * Math.PI) * 0.1;
                knifeGroup.rotation.y = 0.4 + spinRotations;
                rightArm.rotation.x = Math.sin(progress * Math.PI) * 0.5;
                targetFOV = 75 + shake * 80;
            }
            
            else if (currentAnimation === 'flip') {
                const parabola = Math.sin(progress * Math.PI);
                if (progress < 0.35) {
                    const phase = easeInOutCubic(progress / 0.35);
                    knifeGroup.position.y = smoothLerp(-0.28, -0.1, phase);
                    knifeGroup.rotation.x = smoothLerp(-0.1, 1.5, phase);
                    rightArm.rotation.x = -phase * 0.8;
                } else if (progress < 0.7) {
                    const phase = (progress - 0.35) / 0.35;
                    knifeGroup.position.y = -0.1 + Math.sin(phase * Math.PI) * 0.5;
                    knifeGroup.rotation.x = 1.5 + phase * Math.PI * 4;
                    targetFOV = 68 + Math.sin(phase * Math.PI) * 8;
                } else {
                    const phase = easeOutBack((progress - 0.7) / 0.3);
                    knifeGroup.position.y = smoothLerp(0.4, -0.28, phase);
                    knifeGroup.rotation.x = smoothLerp(1.5 + Math.PI * 1.4, -0.1, phase);
                    rightArm.rotation.x = smoothLerp(-0.5, 0, phase);
                    targetFOV = smoothLerp(76, 75, phase);
                }
            }
            
            else if (currentAnimation === 'twirl') {
                const twirls = progress * Math.PI * 10;
                const spiral = progress * Math.PI * 3;
                const spiralRadius = 0.15 * Math.sin(progress * Math.PI);
                knifeGroup.position.x = 0.35 + Math.cos(spiral) * spiralRadius;
                knifeGroup.position.y = -0.28 + Math.sin(spiral) * spiralRadius * 0.7;
                knifeGroup.rotation.x = -0.1 + Math.sin(twirls * 1.4) * 0.9;
                knifeGroup.rotation.y = 0.4 + twirls * 1.3;
                knifeGroup.rotation.z = 0.3 + Math.cos(twirls) * 0.7;
                rightArm.rotation.x = Math.sin(spiral) * 0.4;
                rightArm.rotation.y = Math.sin(twirls * 0.5) * 0.45;
                targetFOV = 75 + Math.sin(twirls * 0.3) * 4;
            }
            
            else if (currentAnimation === 'juggle') {
                const juggleCycle = progress * 4;
                const isRightHand = Math.floor(juggleCycle) % 2 === 0;
                const phaseInCycle = juggleCycle % 1;
                const arc = Math.sin(phaseInCycle * Math.PI);
                
                if (isRightHand) {
                    knifeGroup.position.x = smoothLerp(0.35, -0.25, phaseInCycle);
                } else {
                    knifeGroup.position.x = smoothLerp(-0.25, 0.35, phaseInCycle);
                }
                knifeGroup.position.y = -0.28 + arc * 0.4;
                knifeGroup.rotation.x = -0.1 + phaseInCycle * Math.PI * 2;
                targetFOV = 75 + arc * 5;
            }
            
            else if (currentAnimation === 'cinematic') {
                if (progress < 0.2) {
                    const phase = easeInOutCubic(progress / 0.2);
                    knifeGroup.position.x = smoothLerp(0.35, 0, phase);
                    knifeGroup.position.y = smoothLerp(-0.28, 0, phase);
                    knifeGroup.position.z = smoothLerp(-0.45, -0.25, phase);
                    knifeGroup.rotation.x = -0.1 + phase * Math.PI * 2;
                    targetFOV = smoothLerp(75, 60, phase);
                } else if (progress < 0.4) {
                    const phase = (progress - 0.2) / 0.2;
                    const spinRot = phase * Math.PI * 6;
                    knifeGroup.position.set(0, 0, -0.25);
                    knifeGroup.rotation.y = 0.4 + spinRot;
                    targetFOV = 60 - Math.abs(Math.sin(spinRot)) * 5;
                } else if (progress < 0.6) {
                    const phase = (progress - 0.4) / 0.2;
                    const arc = Math.sin(phase * Math.PI);
                    knifeGroup.position.y = arc * 0.6;
                    knifeGroup.rotation.x = Math.PI * 2 + phase * Math.PI * 5;
                    targetFOV = 55 + arc * 10;
                } else if (progress < 0.8) {
                    const phase = easeOutBack((progress - 0.6) / 0.2);
                    const twirlRot = (progress - 0.6) * 40;
                    knifeGroup.position.y = smoothLerp(0.6, -0.15, phase);
                    knifeGroup.rotation.y = 0.4 + twirlRot;
                    targetFOV = smoothLerp(65, 68, phase);
                } else {
                    const phase = easeInOutCubic((progress - 0.8) / 0.2);
                    knifeGroup.position.x = smoothLerp(0, 0.35, phase);
                    knifeGroup.position.y = smoothLerp(-0.15, -0.28, phase);
                    knifeGroup.position.z = smoothLerp(-0.25, -0.45, phase);
                    knifeGroup.rotation.x = smoothLerp(0, -0.1, phase);
                    targetFOV = smoothLerp(68, 75, phase);
                }
            }
            
            if (progress >= 1) {
                currentAnimation = 'idle';
                animationProgress = 0;
                resetKnifePosition();
                rightArm.rotation.set(0, 0, 0);
                leftArm.rotation.set(0, 0, 0);
                rightArm.position.set(0.25, -0.3, -0.5);
                leftArm.position.set(-0.25, -0.3, -0.5);
                viewmodelGroup.position.set(0, 0, 0);
                viewmodelGroup.rotation.set(0, 0, 0);
                targetFOV = settings.fov; // Retour au FOV des param√®tres
            }
        }
        
        // Animation
        let currentRotationX = 0;
        let currentRotationY = 0;
        let bobPhase = 0;
        let isMoving = false;
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            const time = currentTime * 0.001;
            
            // Arr√™ter les animations si en pause
            if (isPaused) {
                renderer.render(scene, camera);
                return;
            }
            
            isMoving = keys['z'] || keys['w'] || keys['s'] || keys['q'] || keys['a'] || keys['d'];
            
            updateMovement();
            
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = currentRotationY;
            camera.rotation.x = currentRotationX;
            
            cameraFOV += (targetFOV - cameraFOV) * 0.1;
            camera.fov = cameraFOV;
            camera.updateProjectionMatrix();
            
            // Appliquer les param√®tres d'ombres
            renderer.shadowMap.enabled = settings.shadows;
            
            if (isMoving && currentAnimation === 'idle') {
                bobPhase += 0.15;
                const bobY = Math.sin(bobPhase) * 0.015;
                const bobX = Math.cos(bobPhase * 0.5) * 0.01;
                viewmodelGroup.position.y = bobY;
                viewmodelGroup.position.x = bobX;
                rightArm.rotation.x = Math.sin(bobPhase) * 0.1;
                leftArm.rotation.x = Math.sin(bobPhase + Math.PI) * 0.1;
            } else if (currentAnimation === 'idle') {
                viewmodelGroup.position.y += (0 - viewmodelGroup.position.y) * 0.1;
                viewmodelGroup.position.x += (0 - viewmodelGroup.position.x) * 0.1;
                rightArm.rotation.x += (0 - rightArm.rotation.x) * 0.1;
                leftArm.rotation.x += (0 - leftArm.rotation.x) * 0.1;
            }
            
            if (currentAnimation === 'idle') {
                const idleSwayY = Math.sin(time * 0.8) * 0.005;
                const idleSwayX = Math.cos(time * 0.5) * 0.003;
                viewmodelGroup.rotation.z += (idleSwayX - viewmodelGroup.rotation.z) * 0.1;
                viewmodelGroup.rotation.x += (idleSwayY - viewmodelGroup.rotation.x) * 0.1;
            }
            
            updateKnifeAnimation(deltaTime, time);
            
            // Animation des reflets sur la lame
            const pulseIntensity = (Math.sin(time * 2) + 1) * 0.15;
            bladeMaterial.emissiveIntensity = 0.15 + pulseIntensity * 0.5;
            bladeEdgeMaterial.emissiveIntensity = 0.25 + pulseIntensity;
            
            // Animation de l'or
            const goldPulse = (Math.sin(time * 1.5) + 1) * 0.2;
            goldAccentMaterial.emissiveIntensity = 0.4 + goldPulse * 0.3;
            
            // Animation du glow cyan
            glowMaterial.opacity = 0.15 + Math.sin(time * 3) * 0.08;
            
            // Animation des sparkles (scintillement)
            knifeGroup.children.forEach((child, index) => {
                if (child.material === sparkleMaterial) {
                    child.material.opacity = 0.3 + Math.sin(time * 5 + index) * 0.5;
                    child.scale.set(
                        1 + Math.sin(time * 4 + index) * 0.3,
                        1 + Math.sin(time * 4 + index) * 0.3,
                        1 + Math.sin(time * 4 + index) * 0.3
                    );
                }
            });
            
            // Animation des particules atmosph√©riques
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] += particleVelocities[i].x;
                positions[i * 3 + 1] += particleVelocities[i].y;
                positions[i * 3 + 2] += particleVelocities[i].z;
                
                // Reset si trop haut
                if (positions[i * 3 + 1] > 30) {
                    positions[i * 3 + 1] = -10;
                }
                
                // Boucle horizontale
                if (Math.abs(positions[i * 3]) > 25) positions[i * 3] *= -0.9;
                if (Math.abs(positions[i * 3 + 2]) > 25) positions[i * 3 + 2] *= -0.9;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            
            // Rotation lente du syst√®me de particules
            particleSystem.rotation.y += 0.0002;
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
