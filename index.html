<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bras R6 Roblox 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Arial', sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }
        
        .info-panel h2 {
            margin: 0 0 15px 0;
            font-size: 24px;
            color: #00d4ff;
        }
        
        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .icon {
            margin-right: 10px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="info-panel">
        <h2>üéÆ FPS Karambit</h2>
        <div class="control-item">
            <span class="icon">üñ±Ô∏è</span>
            <span>Souris pour regarder autour</span>
        </div>
        <div class="control-item">
            <span class="icon">‚å®Ô∏è</span>
            <span>ZQSD / WASD pour bouger</span>
        </div>
        <h3 style="margin: 15px 0 10px 0; color: #00d4ff; font-size: 18px;">Animations du Karambit:</h3>
        <div class="control-item">
            <span class="icon">üîç</span>
            <span><strong>F</strong> - Inspection (360¬∞ rotate)</span>
        </div>
        <div class="control-item">
            <span class="icon">üåÄ</span>
            <span><strong>R</strong> - Spin rapide</span>
        </div>
        <div class="control-item">
            <span class="icon">üéØ</span>
            <span><strong>E</strong> - Flip dans l'air</span>
        </div>
        <div class="control-item">
            <span class="icon">‚ú®</span>
            <span><strong>G</strong> - Twirl complexe</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configuration de la sc√®ne
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        // Cam√©ra premi√®re personne
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 0);
        camera.lookAt(0, 0, -5);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lumi√®res
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(-5, 3, -5);
        scene.add(pointLight);
        
        // Base plate (plateforme)
        const platformGeometry = new THREE.BoxGeometry(8, 0.3, 8);
        const platformMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a4a4a,
            roughness: 0.7,
            metalness: 0.3
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.y = -2.5;
        platform.receiveShadow = true;
        scene.add(platform);
        
        // Grille au sol
        const gridHelper = new THREE.GridHelper(10, 10, 0x666666, 0x444444);
        gridHelper.position.y = -2.35;
        scene.add(gridHelper);
        
        // Groupe viewmodel attach√© √† la cam√©ra
        const viewmodelGroup = new THREE.Group();
        camera.add(viewmodelGroup);
        scene.add(camera);
        
        // Mat√©riau pour les bras R6
        const armMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffcc99,
            roughness: 0.5,
            metalness: 0.2
        });
        
        // BRAS DROIT (bloc R6)
        const rightArmGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15);
        const rightArm = new THREE.Mesh(rightArmGeometry, armMaterial);
        rightArm.position.set(0.25, -0.3, -0.5);
        rightArm.castShadow = true;
        viewmodelGroup.add(rightArm);
        
        // BRAS GAUCHE (bloc R6)
        const leftArmGeometry = new THREE.BoxGeometry(0.15, 0.8, 0.15);
        const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
        leftArm.position.set(-0.25, -0.3, -0.5);
        leftArm.castShadow = true;
        viewmodelGroup.add(leftArm);
        
        // === CR√âATION DU KARAMBIT ===
        const knifeGroup = new THREE.Group();
        
        // Lame principale (argent√©e brillante)
        const bladeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe8e8e8,
            metalness: 0.95,
            roughness: 0.15,
            emissive: 0x222222,
            emissiveIntensity: 0.1
        });
        
        // Lame courb√©e principale
        const bladeMainGeometry = new THREE.BoxGeometry(0.03, 0.35, 0.08);
        const bladeMain = new THREE.Mesh(bladeMainGeometry, bladeMaterial);
        bladeMain.position.set(0, -0.15, 0);
        bladeMain.rotation.z = 0.4;
        knifeGroup.add(bladeMain);
        
        // Pointe recourb√©e
        const bladeTipGeometry = new THREE.BoxGeometry(0.025, 0.15, 0.07);
        const bladeTip = new THREE.Mesh(bladeTipGeometry, bladeMaterial);
        bladeTip.position.set(0.12, -0.28, 0);
        bladeTip.rotation.z = -0.3;
        knifeGroup.add(bladeTip);
        
        // Tranchant (partie brillante)
        const edgeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            metalness: 1.0,
            roughness: 0.05,
            emissive: 0x444444,
            emissiveIntensity: 0.2
        });
        const edgeGeometry = new THREE.BoxGeometry(0.015, 0.35, 0.01);
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.position.set(0.015, -0.15, 0.035);
        edge.rotation.z = 0.4;
        knifeGroup.add(edge);
        
        // Manche noir avec texture
        const handleMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0a0a0a,
            roughness: 0.6,
            metalness: 0.2
        });
        const handleGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.08);
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.set(0, 0.08, 0);
        knifeGroup.add(handle);
        
        // D√©tails dor√©s sur le manche
        const goldMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffd700,
            metalness: 0.9,
            roughness: 0.2,
            emissive: 0x442200,
            emissiveIntensity: 0.3
        });
        
        // Bande dor√©e 1
        const goldBand1Geometry = new THREE.BoxGeometry(0.052, 0.025, 0.082);
        const goldBand1 = new THREE.Mesh(goldBand1Geometry, goldMaterial);
        goldBand1.position.set(0, 0.05, 0);
        knifeGroup.add(goldBand1);
        
        // Bande dor√©e 2
        const goldBand2 = new THREE.Mesh(goldBand1Geometry, goldMaterial);
        goldBand2.position.set(0, 0.12, 0);
        knifeGroup.add(goldBand2);
        
        // Anneau du karambit (signature)
        const ringGeometry = new THREE.TorusGeometry(0.045, 0.012, 8, 16);
        const ring = new THREE.Mesh(ringGeometry, goldMaterial);
        ring.position.set(0, 0.22, 0);
        ring.rotation.x = Math.PI / 2;
        knifeGroup.add(ring);
        
        // Rivet d√©coratif
        const rivetGeometry = new THREE.SphereGeometry(0.008, 8, 8);
        const rivet1 = new THREE.Mesh(rivetGeometry, goldMaterial);
        rivet1.position.set(0, 0.08, 0.042);
        knifeGroup.add(rivet1);
        
        const rivet2 = new THREE.Mesh(rivetGeometry, goldMaterial);
        rivet2.position.set(0, 0.08, -0.042);
        knifeGroup.add(rivet2);
        
        // Position du couteau dans la main droite (mieux tenu, pas dans le bras)
        knifeGroup.position.set(0.35, -0.28, -0.45);
        knifeGroup.rotation.set(-0.1, 0.4, 0.3);
        viewmodelGroup.add(knifeGroup);
        
        // Contr√¥les premi√®re personne
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // Invers√© pour contr√¥les naturels
            targetRotationY = -mouseX * Math.PI * 0.5;
            targetRotationX = -mouseY * Math.PI * 0.3;
        });
        
        // Mouvement avec les touches ZQSD / WASD
        const keys = {};
        const moveSpeed = 0.1;
        
        // Variables pour les animations du couteau
        let currentAnimation = 'idle';
        let animationProgress = 0;
        let animationDuration = 0;
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Animations du couteau
            if (e.key.toLowerCase() === 'f' && currentAnimation === 'idle') {
                currentAnimation = 'inspect';
                animationProgress = 0;
                animationDuration = 4.0; // Plus long pour montrer tous les d√©tails
            }
            if (e.key.toLowerCase() === 'r' && currentAnimation === 'idle') {
                currentAnimation = 'spin';
                animationProgress = 0;
                animationDuration = 2.0;
            }
            if (e.key.toLowerCase() === 'e' && currentAnimation === 'idle') {
                currentAnimation = 'flip';
                animationProgress = 0;
                animationDuration = 1.6;
            }
            if (e.key.toLowerCase() === 'g' && currentAnimation === 'idle') {
                currentAnimation = 'twirl';
                animationProgress = 0;
                animationDuration = 2.8;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        function updateMovement() {
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();
            
            if (keys['z'] || keys['w']) {
                camera.position.add(forward.multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                camera.position.sub(forward.multiplyScalar(moveSpeed));
            }
            if (keys['q'] || keys['a']) {
                camera.position.sub(right.multiplyScalar(moveSpeed));
            }
            if (keys['d']) {
                camera.position.add(right.multiplyScalar(moveSpeed));
            }
        }
        
        // Fonction d'easing pour des animations fluides
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        function easeOutElastic(t) {
            const c4 = (2 * Math.PI) / 3;
            return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
        }
        
        // R√©initialiser la position du couteau
        function resetKnifePosition() {
            knifeGroup.position.set(0.35, -0.28, -0.45);
            knifeGroup.rotation.set(-0.1, 0.4, 0.3);
        }
        
        // Fonction d'interpolation pour transitions fluides
        function smoothLerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        // Animations du couteau avec coordination bras-couteau am√©lior√©e
        function updateKnifeAnimation(deltaTime, time) {
            if (currentAnimation === 'idle') {
                // Animation idle normale
                resetKnifePosition();
                knifeGroup.rotation.y = 0.4 + Math.sin(time * 0.7) * 0.02;
                knifeGroup.rotation.z = 0.3 + Math.sin(time * 0.9) * 0.015;
                return;
            }
            
            animationProgress += deltaTime;
            const progress = Math.min(animationProgress / animationDuration, 1);
            const eased = easeInOutCubic(progress);
            
            if (currentAnimation === 'inspect') {
                // INSPECT (F) - Inspection professionnelle avec les deux mains
                // Phase 1: Ramener au centre (0-0.25)
                // Phase 2: Rotation lente (0.25-0.75)
                // Phase 3: Retour (0.75-1)
                
                if (progress < 0.25) {
                    const phase = progress / 0.25;
                    const phaseEased = easeInOutCubic(phase);
                    
                    // Ramener le couteau vers le centre, plus haut et proche
                    knifeGroup.position.x = smoothLerp(0.35, 0.05, phaseEased);
                    knifeGroup.position.y = smoothLerp(-0.28, -0.05, phaseEased);
                    knifeGroup.position.z = smoothLerp(-0.45, -0.3, phaseEased);
                    
                    knifeGroup.rotation.x = smoothLerp(-0.1, 0.4, phaseEased);
                    knifeGroup.rotation.y = smoothLerp(0.4, 0.2, phaseEased);
                    knifeGroup.rotation.z = smoothLerp(0.3, 0.1, phaseEased);
                    
                    // Bras droit se rapproche
                    rightArm.position.x = smoothLerp(0.25, 0.18, phaseEased);
                    rightArm.position.z = smoothLerp(-0.5, -0.4, phaseEased);
                    rightArm.rotation.y = smoothLerp(0, -0.35, phaseEased);
                    rightArm.rotation.x = smoothLerp(0, -0.15, phaseEased);
                    
                    // Bras gauche vient soutenir
                    leftArm.position.x = smoothLerp(-0.25, -0.18, phaseEased);
                    leftArm.position.z = smoothLerp(-0.5, -0.4, phaseEased);
                    leftArm.rotation.y = smoothLerp(0, 0.35, phaseEased);
                    leftArm.rotation.x = smoothLerp(0, -0.15, phaseEased);
                    
                } else if (progress < 0.75) {
                    const phase = (progress - 0.25) / 0.5;
                    
                    // Position stable au centre
                    knifeGroup.position.x = 0.05;
                    knifeGroup.position.y = -0.05;
                    knifeGroup.position.z = -0.3;
                    
                    // Rotation fluide pour admirer le couteau
                    const rotations = phase * Math.PI * 2.5;
                    knifeGroup.rotation.x = 0.4 + Math.sin(rotations * 0.8) * 0.25;
                    knifeGroup.rotation.y = 0.2 + rotations;
                    knifeGroup.rotation.z = 0.1 + Math.cos(rotations * 0.6) * 0.2;
                    
                    // Bras stabilis√©s avec micro-mouvements
                    rightArm.position.x = 0.18;
                    rightArm.position.z = -0.4;
                    rightArm.rotation.y = -0.35 + Math.sin(rotations) * 0.08;
                    rightArm.rotation.x = -0.15 + Math.cos(rotations * 0.5) * 0.05;
                    
                    leftArm.position.x = -0.18;
                    leftArm.position.z = -0.4;
                    leftArm.rotation.y = 0.35 - Math.sin(rotations) * 0.08;
                    leftArm.rotation.x = -0.15 + Math.cos(rotations * 0.5) * 0.05;
                    
                } else {
                    const phase = (progress - 0.75) / 0.25;
                    const phaseEased = easeInOutCubic(phase);
                    
                    // Retour position initiale fluide
                    knifeGroup.position.x = smoothLerp(0.05, 0.35, phaseEased);
                    knifeGroup.position.y = smoothLerp(-0.05, -0.28, phaseEased);
                    knifeGroup.position.z = smoothLerp(-0.3, -0.45, phaseEased);
                    
                    const finalRotY = Math.PI * 2.5 * 0.5 + 0.2;
                    knifeGroup.rotation.x = smoothLerp(0.4, -0.1, phaseEased);
                    knifeGroup.rotation.y = smoothLerp(finalRotY, 0.4, phaseEased);
                    knifeGroup.rotation.z = smoothLerp(0.1, 0.3, phaseEased);
                    
                    rightArm.position.x = smoothLerp(0.18, 0.25, phaseEased);
                    rightArm.position.z = smoothLerp(-0.4, -0.5, phaseEased);
                    rightArm.rotation.y = smoothLerp(-0.35, 0, phaseEased);
                    rightArm.rotation.x = smoothLerp(-0.15, 0, phaseEased);
                    
                    leftArm.position.x = smoothLerp(-0.18, -0.25, phaseEased);
                    leftArm.position.z = smoothLerp(-0.4, -0.5, phaseEased);
                    leftArm.rotation.y = smoothLerp(0.35, 0, phaseEased);
                    leftArm.rotation.x = smoothLerp(-0.15, 0, phaseEased);
                }
            }
            
            else if (currentAnimation === 'spin') {
                // SPIN (R) - Spin rapide avec contr√¥le du poignet
                const spinRotations = easeOutElastic(progress) * Math.PI * 10;
                
                // Petit mouvement circulaire pendant le spin
                const radius = 0.06 * Math.sin(progress * Math.PI);
                knifeGroup.position.x = 0.35 + Math.cos(spinRotations * 3) * radius;
                knifeGroup.position.y = -0.28 + Math.sin(progress * Math.PI) * 0.06;
                knifeGroup.position.z = -0.45 + Math.sin(spinRotations * 2) * radius * 0.5;
                
                // Rotation principale sur Y avec oscillations sur X et Z
                knifeGroup.rotation.x = -0.1 + Math.sin(spinRotations * 1.2) * 0.25;
                knifeGroup.rotation.y = 0.4 + spinRotations;
                knifeGroup.rotation.z = 0.3 + Math.cos(spinRotations * 0.8) * 0.2;
                
                // Mouvement de poignet du bras droit
                rightArm.rotation.x = Math.sin(progress * Math.PI) * 0.35;
                rightArm.rotation.z = -Math.sin(progress * Math.PI) * 0.25;
                rightArm.position.y = -0.3 + Math.sin(progress * Math.PI) * 0.08;
                rightArm.position.x = 0.25 + Math.cos(progress * Math.PI * 2) * 0.03;
                
                // Bras gauche en contrepoids
                leftArm.rotation.x = -Math.sin(progress * Math.PI) * 0.15;
            }
            
            else if (currentAnimation === 'flip') {
                // FLIP (E) - Flip vertical avec lancer et catch propre
                const parabola = Math.sin(progress * Math.PI);
                const isThrow = progress < 0.4;
                const isFlight = progress >= 0.4 && progress < 0.7;
                const isCatch = progress >= 0.7;
                
                if (isThrow) {
                    // Phase de lancer (0-0.4)
                    const throwPhase = progress / 0.4;
                    const throwEased = easeInOutCubic(throwPhase);
                    
                    knifeGroup.position.x = 0.35 - throwEased * 0.1;
                    knifeGroup.position.y = -0.28 + throwEased * 0.15;
                    knifeGroup.position.z = -0.45 + throwEased * 0.05;
                    
                    knifeGroup.rotation.x = -0.1 + throwEased * 0.8;
                    knifeGroup.rotation.y = 0.4;
                    knifeGroup.rotation.z = 0.3 + throwEased * 0.3;
                    
                    rightArm.rotation.x = -throwEased * 0.7;
                    rightArm.position.y = -0.3 - throwEased * 0.2;
                    
                } else if (isFlight) {
                    // Phase de vol (0.4-0.7)
                    const flightPhase = (progress - 0.4) / 0.3;
                    
                    knifeGroup.position.x = 0.25 + Math.sin(flightPhase * Math.PI) * 0.08;
                    knifeGroup.position.y = -0.13 + parabola * 0.35;
                    knifeGroup.position.z = -0.4;
                    
                    // Rotation compl√®te pendant le vol
                    knifeGroup.rotation.x = 0.7 + flightPhase * Math.PI * 3;
                    knifeGroup.rotation.y = 0.4 + flightPhase * Math.PI * 0.5;
                    knifeGroup.rotation.z = 0.6 + flightPhase * Math.PI * 2;
                    
                    // Bras se pr√©pare √† attraper
                    rightArm.rotation.x = -0.7 + flightPhase * 0.4;
                    rightArm.position.y = -0.5 + flightPhase * 0.1;
                    
                } else {
                    // Phase de catch (0.7-1)
                    const catchPhase = (progress - 0.7) / 0.3;
                    const catchEased = easeInOutCubic(catchPhase);
                    
                    knifeGroup.position.x = smoothLerp(0.25, 0.35, catchEased);
                    knifeGroup.position.y = smoothLerp(0.22, -0.28, catchEased);
                    knifeGroup.position.z = smoothLerp(-0.4, -0.45, catchEased);
                    
                    const finalRotX = Math.PI * 3 * 0.3 + 0.7;
                    knifeGroup.rotation.x = smoothLerp(finalRotX, -0.1, catchEased);
                    knifeGroup.rotation.y = smoothLerp(0.4 + Math.PI * 0.15, 0.4, catchEased);
                    knifeGroup.rotation.z = smoothLerp(0.6 + Math.PI * 0.6, 0.3, catchEased);
                    
                    rightArm.rotation.x = smoothLerp(-0.3, 0, catchEased);
                    rightArm.position.y = smoothLerp(-0.4, -0.3, catchEased);
                }
                
                // Bras gauche r√©agit
                leftArm.rotation.x = parabola * 0.25;
                leftArm.position.y = -0.3 + parabola * 0.05;
            }
            
            else if (currentAnimation === 'twirl') {
                // TWIRL (G) - Twirl complexe avec mouvement en spirale
                const twirls = progress * Math.PI * 8;
                const spiral = progress * Math.PI * 2;
                
                // Mouvement en spirale √©l√©gante
                const spiralRadius = 0.1 * Math.sin(progress * Math.PI);
                knifeGroup.position.x = 0.35 + Math.cos(spiral) * spiralRadius;
                knifeGroup.position.y = -0.28 + Math.sin(spiral) * spiralRadius * 0.8;
                knifeGroup.position.z = -0.45 + Math.sin(twirls * 0.5) * 0.08;
                
                // Rotations multiples coordonn√©es
                knifeGroup.rotation.x = -0.1 + Math.sin(twirls * 1.3) * 0.7;
                knifeGroup.rotation.y = 0.4 + twirls * 1.2;
                knifeGroup.rotation.z = 0.3 + Math.cos(twirls * 0.9) * 0.6;
                
                // Mouvement de poignet fluide et √©l√©gant
                rightArm.rotation.x = Math.sin(spiral) * 0.3;
                rightArm.rotation.y = Math.sin(twirls * 0.4) * 0.35;
                rightArm.rotation.z = Math.cos(twirls * 0.3) * 0.25;
                rightArm.position.x = 0.25 + Math.sin(spiral) * 0.04;
                rightArm.position.y = -0.3 + Math.cos(spiral) * 0.05;
                
                // Bras gauche fait le contrepoint
                leftArm.rotation.x = Math.sin(twirls * 0.35) * 0.2;
                leftArm.rotation.y = -Math.cos(spiral) * 0.25;
                leftArm.position.y = -0.3 - Math.sin(spiral) * 0.03;
            }
            
            // Fin de l'animation avec reset fluide
            if (progress >= 1) {
                currentAnimation = 'idle';
                animationProgress = 0;
                resetKnifePosition();
                // Reset progressif des bras
                rightArm.rotation.set(0, 0, 0);
                leftArm.rotation.set(0, 0, 0);
                rightArm.position.set(0.25, -0.3, -0.5);
                leftArm.position.set(-0.25, -0.3, -0.5);
            }
        }
        
        // Animation
        let currentRotationX = 0;
        let currentRotationY = 0;
        let bobPhase = 0;
        let isMoving = false;
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            const time = currentTime * 0.001;
            
            // D√©tection du mouvement
            isMoving = keys['z'] || keys['w'] || keys['s'] || keys['q'] || keys['a'] || keys['d'];
            
            // Mouvement ZQSD
            updateMovement();
            
            // Interpolation douce de la rotation de la cam√©ra
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = currentRotationY;
            camera.rotation.x = currentRotationX;
            
            // === ANIMATIONS DU VIEWMODEL ===
            
            // Balancement de marche (head bobbing) - seulement si pas d'animation de couteau
            if (isMoving && currentAnimation === 'idle') {
                bobPhase += 0.15;
                const bobY = Math.sin(bobPhase) * 0.015;
                const bobX = Math.cos(bobPhase * 0.5) * 0.01;
                viewmodelGroup.position.y = bobY;
                viewmodelGroup.position.x = bobX;
                
                // Balancement des bras pendant la marche
                rightArm.rotation.x = Math.sin(bobPhase) * 0.1;
                leftArm.rotation.x = Math.sin(bobPhase + Math.PI) * 0.1;
            } else if (currentAnimation === 'idle') {
                // Retour √† la position de repos
                viewmodelGroup.position.y += (0 - viewmodelGroup.position.y) * 0.1;
                viewmodelGroup.position.x += (0 - viewmodelGroup.position.x) * 0.1;
                rightArm.rotation.x += (0 - rightArm.rotation.x) * 0.1;
                leftArm.rotation.x += (0 - leftArm.rotation.x) * 0.1;
            }
            
            // Balancement idle subtil (breathing effect) - seulement si pas d'animation
            if (currentAnimation === 'idle') {
                const idleSwayY = Math.sin(time * 0.8) * 0.005;
                const idleSwayX = Math.cos(time * 0.5) * 0.003;
                viewmodelGroup.rotation.z = idleSwayX;
                viewmodelGroup.rotation.x = idleSwayY;
            }
            
            // Animation du couteau
            updateKnifeAnimation(deltaTime, time);
            
            // Animation de reflet sur la lame
            const pulseIntensity = (Math.sin(time * 2) + 1) * 0.15;
            bladeMaterial.emissiveIntensity = 0.1 + pulseIntensity;
            edgeMaterial.emissiveIntensity = 0.2 + pulseIntensity;
            
            // Animation de brillance sur l'or
            const goldPulse = (Math.sin(time * 1.5) + 1) * 0.2;
            goldMaterial.emissiveIntensity = 0.3 + goldPulse;
            
            renderer.render(scene, camera);
        }
        
        // Gestion du redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // D√©marrage de l'animation
        animate();
    </script>
</body>
</html>
